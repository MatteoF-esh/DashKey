<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README_DIRECT_MESSAGING.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README_DIRECT_MESSAGING.md" />
              <option name="updatedContent" value="# Système de Messagerie avec Livraison Directe&#10;&#10;##  Vue d'ensemble&#10;&#10;Ce système de messagerie privilégie la **livraison directe** des messages entre utilisateurs connectés, et ne stocke les messages dans la base de données serveur **que si le destinataire est hors ligne**.&#10;&#10;##  Objectifs&#10;&#10;1. **Performance** : Les messages sont livrés instantanément via Socket.IO sans passer par la base de données&#10;2. **Persistance locale** : Tous les messages sont stockés localement sur le téléphone Android (Room Database)&#10;3. **Fiabilité** : Si le destinataire est offline, le message est stocké temporairement sur le serveur (24h max)&#10;4. **Nettoyage automatique** : Les messages livrés sont supprimés du serveur après 24h&#10;&#10;##  Workflow de l'envoi d'un message&#10;&#10;```&#10;Utilisateur A envoie un message à Utilisateur B&#10;         ↓&#10;1. Message stocké localement (Room) sur téléphone A&#10;         ↓&#10;2. Message envoyé via Socket.IO au serveur&#10;         ↓&#10;3. Serveur vérifie si B est connecté&#10;         ↓&#10;    ┌────────────┴────────────┐&#10;    ↓                         ↓&#10;B est EN LIGNE            B est OFFLINE&#10;    ↓                         ↓&#10;Livraison DIRECTE     Stockage dans BDD serveur&#10;via Socket.IO              (24h maximum)&#10;    ↓                         ↓&#10;B reçoit le message      B recevra le message&#10;instantanément          à sa prochaine connexion&#10;    ↓                         ↓&#10;Stocké localement       Livré + stocké localement&#10;sur téléphone B              puis supprimé du serveur&#10;```&#10;&#10;## ️ Architecture&#10;&#10;### Serveur (Node.js)&#10;&#10;**Fichiers :**&#10;- `server.js` - Serveur principal avec livraison directe&#10;- `migration_add_delivered.sql` - Migration SQL pour ajouter le champ `delivered`&#10;&#10;**Fonctionnalités clés :**&#10;- Suivi des utilisateurs connectés : `Map&lt;userId, Set&lt;socketId&gt;&gt;`&#10;- Livraison directe si destinataire en ligne&#10;- Stockage temporaire si destinataire offline&#10;- Nettoyage automatique toutes les heures des messages &gt; 24h&#10;- Notification en temps réel (demandes d'ami, suppression d'amitié, etc.)&#10;&#10;**Événements Socket.IO :**&#10;- `authenticate` - Authentification de l'utilisateur&#10;- `send_message` - Envoi d'un message&#10;- `message` - Réception d'un message&#10;- `message_delivered` - Confirmation de livraison directe&#10;- `message_stored` - Confirmation de stockage offline&#10;- `friend_request_received` - Notification de demande d'ami&#10;- `friendship_deleted` - Notification de suppression d'amitié&#10;&#10;### Client Android (Kotlin)&#10;&#10;**Fichiers :**&#10;- `Message.kt` - Modèle de données pour le stockage local&#10;- `AppDatabase.kt` - Base de données Room (version 3)&#10;- `DirectMessagingService.kt` - Service Socket.IO pour la messagerie en temps réel&#10;- `DirectMessagingViewModel.kt` - ViewModel pour gérer les messages&#10;&#10;**Base de données locale (Room) :**&#10;```kotlin&#10;@Entity(tableName = &quot;messages&quot;)&#10;data class Message(&#10;    val id: Long,&#10;    val senderId: Int,&#10;    val receiverId: Int,&#10;    val senderEmail: String,&#10;    val text: String,&#10;    val timestamp: Long,&#10;    val conversationId: String,&#10;    val isSentByMe: Boolean,&#10;    val serverMessageId: Int?, // ID serveur si message était offline&#10;    val fromServer: Boolean     // true si récupéré depuis serveur&#10;)&#10;```&#10;&#10;##  Démarrage&#10;&#10;### 1. Base de données MySQL&#10;&#10;Exécutez la migration :&#10;```bash&#10;mysql -u root -p votre_database &lt; migration_add_delivered.sql&#10;```&#10;&#10;Ou manuellement :&#10;```sql&#10;ALTER TABLE `message` ADD COLUMN `delivered` TINYINT(1) NOT NULL DEFAULT 0 AFTER `content`;&#10;CREATE INDEX idx_receiver_delivered ON `message` (`receiver_id`, `delivered`);&#10;CREATE INDEX idx_created_delivered ON `message` (`created_at`, `delivered`);&#10;```&#10;&#10;### 2. Serveur Node.js&#10;&#10;```bash&#10;# Installer les dépendances&#10;npm install&#10;&#10;# Configurer les variables d'environnement (.env)&#10;PORT=3000&#10;DB_HOST=localhost&#10;DB_PORT=3306&#10;DB_USER=root&#10;DB_PASSWORD=votre_password&#10;DB_NAME=votre_database&#10;JWT_SECRET=votre_secret_key&#10;JWT_EXPIRES_IN=7d&#10;&#10;# Démarrer le serveur&#10;node server.js&#10;```&#10;&#10;Le serveur affichera :&#10;```&#10;✅ Database connected&#10; Server listening on port 3000&#10; Socket.IO ready for DIRECT message delivery&#10; Messages stored in DB ONLY when receiver is offline&#10; JWT authentication enabled&#10;```&#10;&#10;### 3. Application Android&#10;&#10;1. **Mettre à jour `build.gradle.kts`** pour inclure les dépendances Socket.IO :&#10;```kotlin&#10;implementation(&quot;io.socket:socket.io-client:2.1.0&quot;)&#10;```&#10;&#10;2. **Utiliser le nouveau ViewModel** dans votre Activity :&#10;```kotlin&#10;val viewModel: DirectMessagingViewModel by viewModels()&#10;&#10;// Connexion&#10;viewModel.connectMessaging(token, userId, userEmail)&#10;&#10;// Observer l'état de connexion&#10;lifecycleScope.launch {&#10;    viewModel.isConnected.collect { isConnected -&gt;&#10;        // Mettre à jour l'UI&#10;    }&#10;}&#10;&#10;// Envoyer un message&#10;viewModel.sendMessage(&#10;    receiverId = friendUserId,&#10;    receiverEmail = friendEmail,&#10;    content = messageText,&#10;    conversationId = &quot;conv_${myUserId}_${friendUserId}&quot;&#10;)&#10;&#10;// Observer le statut d'envoi&#10;lifecycleScope.launch {&#10;    viewModel.sendStatus.collect { status -&gt;&#10;        when (status) {&#10;            SendStatus.Sending -&gt; { /* Afficher &quot;Envoi...&quot; */ }&#10;            SendStatus.DeliveredDirect -&gt; { /* Afficher &quot;✓✓&quot; */ }&#10;            SendStatus.StoredOffline -&gt; { /* Afficher &quot;✓&quot; */ }&#10;            is SendStatus.Error -&gt; { /* Afficher erreur */ }&#10;        }&#10;    }&#10;}&#10;&#10;// Récupérer les messages d'une conversation&#10;lifecycleScope.launch {&#10;    viewModel.getMessagesForConversation(conversationId).collect { messages -&gt;&#10;        // Afficher les messages&#10;    }&#10;}&#10;```&#10;&#10;##  Avantages du système&#10;&#10;### ✅ Pour les utilisateurs&#10;&#10;- **Messages instantanés** : Pas de latence due à l'écriture en BDD&#10;- **Disponibilité offline** : Les messages sont stockés localement, consultables même sans connexion&#10;- **Fiabilité** : Les messages ne sont jamais perdus (stockés côté serveur si destinataire offline)&#10;- **Indicateurs de livraison** : L'utilisateur sait si le message a été livré directement ou sera livré plus tard&#10;&#10;### ✅ Pour le serveur&#10;&#10;- **Charge réduite** : Pas d'écriture en BDD pour chaque message quand les utilisateurs sont en ligne&#10;- **Stockage minimal** : Seulement les messages non livrés (destinataire offline)&#10;- **Nettoyage automatique** : Les messages livrés sont supprimés après 24h&#10;- **Scalabilité** : Peut gérer beaucoup plus d'utilisateurs simultanés&#10;&#10;### ✅ Pour la vie privée&#10;&#10;- **Rétention minimale** : Les messages ne restent pas indéfiniment sur le serveur&#10;- **Stockage local** : L'historique complet reste sur le téléphone de l'utilisateur&#10;- **Contrôle utilisateur** : L'utilisateur peut supprimer ses conversations localement&#10;&#10;##  Sécurité&#10;&#10;- **Authentification JWT** : Tous les endpoints et Socket.IO sont protégés&#10;- **Validation** : Tous les inputs sont validés côté serveur&#10;- **Protection contre les abus** : Les demandes d'ami en double sont bloquées&#10;- **Isolation des conversations** : Un utilisateur ne peut voir que ses propres messages&#10;&#10;##  Débogage&#10;&#10;### Logs serveur&#10;&#10;Le serveur affiche des logs détaillés :&#10;- `✅ User X now has Y socket(s) connected` - Utilisateur connecté&#10;- ` Direct delivery from X to Y` - Livraison directe&#10;- ` Receiver Y offline, storing message in DB` - Stockage offline&#10;- ` Delivering N pending message(s) to user X` - Livraison des messages offline&#10;- `️ Cleaned up N old delivered message(s)` - Nettoyage automatique&#10;&#10;### Logs Android&#10;&#10;Dans le `DirectMessagingService.kt` et `DirectMessagingViewModel.kt`, tous les événements sont loggués avec le tag approprié.&#10;&#10;### Problèmes courants&#10;&#10;**Le destinataire ne reçoit pas le message immédiatement :**&#10;- Vérifier que le destinataire est bien connecté au Socket.IO&#10;- Vérifier les logs serveur pour voir si la livraison directe a fonctionné&#10;&#10;**Les messages ne sont pas stockés localement :**&#10;- Vérifier que la migration de Room (version 3) a bien été appliquée&#10;- Utiliser `.fallbackToDestructiveMigration()` en développement&#10;&#10;**Les messages offline ne sont pas livrés à la connexion :**&#10;- Vérifier que l'authentification Socket.IO fonctionne&#10;- Vérifier que le champ `delivered` existe dans la table `message`&#10;&#10;##  Migration depuis l'ancien système&#10;&#10;Si vous aviez un ancien système qui stockait tous les messages dans la BDD :&#10;&#10;1. **Exporter les conversations importantes** depuis la BDD serveur&#10;2. **Appliquer la migration SQL** pour ajouter le champ `delivered`&#10;3. **Mettre à jour l'app Android** vers la version 3 de la base Room&#10;4. **Démarrer le nouveau serveur** `server.js`&#10;5. Les anciens messages restent dans la BDD mais ne seront plus consultés par la nouvelle version&#10;&#10;##  Résultat&#10;&#10;Vous avez maintenant un système de messagerie moderne qui :&#10;- ⚡ Livre les messages instantanément quand les utilisateurs sont en ligne&#10;-  Stocke les messages localement sur le téléphone&#10;-  Assure la livraison même si le destinataire est offline&#10;-  Nettoie automatiquement les messages temporaires du serveur&#10;-  Réduit drastiquement la charge sur la base de données serveur&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/STATUS_404_RESOLU.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/STATUS_404_RESOLU.md" />
              <option name="updatedContent" value="#  Résolution de l'erreur 404 - Statut actuel&#10;&#10;## ✅ Problème résolu&#10;&#10;L'erreur 404 était causée par des endpoints manquants dans le nouveau `server.js`. J'ai ajouté les endpoints de compatibilité.&#10;&#10;##  Situation actuelle&#10;&#10;### Serveur (server.js)&#10;&#10;Le serveur a maintenant **DEUX modes de fonctionnement** :&#10;&#10;#### Mode 1 : REST API (Ancien - Compatible avec votre code actuel)&#10;- `GET /messages?userId=X` → Retourne une liste vide (messages stockés localement)&#10;- `POST /messages` → Envoie un message (livraison directe si destinataire online, sinon stockage BDD)&#10;&#10;#### Mode 2 : Socket.IO (Nouveau - Livraison directe temps réel)&#10;- Événement `send_message` → Livraison instantanée&#10;- Événement `message` → Réception en temps réel&#10;- Plus performant mais nécessite Socket.IO côté client&#10;&#10;### Application Android&#10;&#10;**Actuellement :** Utilise le mode REST API (ancien code)&#10;- ✅ Fonctionne maintenant (plus d'erreur 404)&#10;- ⚠️ Les messages ne s'affichent pas car ils sont stockés localement dans Room&#10;- ⚠️ Pas de temps réel&#10;&#10;##  Comment ça fonctionne maintenant&#10;&#10;### Scénario 1 : Envoi de message&#10;&#10;```&#10;User A envoie un message à User B&#10;         ↓&#10;App Android appelle POST /messages&#10;         ↓&#10;Serveur vérifie si B est en ligne&#10;         ↓&#10;    ┌────────────┴────────────┐&#10;    ↓                         ↓&#10;B EN LIGNE                B OFFLINE&#10;    ↓                         ↓&#10;Livraison directe      Stockage en BDD&#10;via Socket.IO          (sera livré plus tard)&#10;    ↓                         ↓&#10;Serveur renvoie        Serveur renvoie&#10;delivered:true         delivered:false&#10;```&#10;&#10;### Scénario 2 : Affichage de la conversation&#10;&#10;```&#10;App Android appelle GET /messages?userId=B&#10;         ↓&#10;Serveur retourne []  (liste vide)&#10;         ↓&#10;⚠️ PROBLÈME : Les messages ne s'affichent pas !&#10;```&#10;&#10;**Pourquoi ?** Le nouveau système stocke les messages **UNIQUEMENT** sur le téléphone (Room Database), pas sur le serveur.&#10;&#10;##  Problème actuel&#10;&#10;Votre application essaie d'afficher les messages depuis le serveur, mais :&#10;1. Le serveur retourne une liste vide (par design)&#10;2. Les messages sont dans la base Room locale mais ne sont pas affichés&#10;&#10;## ✅ Solutions&#10;&#10;### Solution 1 : Migration SQL + Utilisation de Room (RECOMMANDÉ)&#10;&#10;C'est la solution complète pour le nouveau système.&#10;&#10;**Étapes :**&#10;&#10;1. **Appliquer la migration SQL :**&#10;   ```bash&#10;   mysql -u root -p votre_database &lt; migration_add_delivered.sql&#10;   ```&#10;&#10;2. **Modifier MessagingScreen pour utiliser Room au lieu de l'API :**&#10;&#10;Le `MessagingScreen` actuel appelle `viewModel.loadMessages()` qui fait un appel REST. Il faut le changer pour lire depuis Room.&#10;&#10;**Je vais créer les fichiers nécessaires dans le prochain message.**&#10;&#10;### Solution 2 : Revenir à l'ancien serveur (TEMPORAIRE)&#10;&#10;Si vous voulez que ça fonctionne immédiatement sans changement :&#10;&#10;1. **Arrêter le serveur actuel**&#10;2. **Utiliser l'ancien serveur :**&#10;   ```bash&#10;   node server-complete-fixed.js&#10;   ```&#10;&#10;Cet ancien serveur stocke TOUS les messages dans la BDD et votre code actuel fonctionnera.&#10;&#10;##  Que faire maintenant ?&#10;&#10;### Option A : Système moderne (recommandé à terme)&#10;- ✅ Messages stockés localement (privé)&#10;- ✅ Livraison directe (rapide)&#10;- ✅ Moins de charge serveur&#10;- ❌ Nécessite modifications Android + migration SQL&#10;&#10;**Je peux vous aider à finaliser cette option.**&#10;&#10;### Option B : Système classique (fonctionne immédiatement)&#10;- ✅ Fonctionne avec votre code actuel&#10;- ✅ Pas de migration nécessaire&#10;- ❌ Tous les messages stockés sur le serveur&#10;- ❌ Plus lent (écriture BDD à chaque message)&#10;&#10;**Utilisez `server-complete-fixed.js` au lieu de `server.js`**&#10;&#10;##  Que voulez-vous faire ?&#10;&#10;**Répondez-moi :**&#10;&#10;1. **&quot;Je veux le système moderne&quot;** → Je vous aide à finaliser la migration (modifications Android + SQL)&#10;2. **&quot;Je veux que ça marche maintenant&quot;** → Utilisez `server-complete-fixed.js`&#10;3. **&quot;Je ne sais pas&quot;** → Je vous recommande l'option 2 pour l'instant, et on migrera plus tard&#10;&#10;##  Fichiers importants&#10;&#10;- `server.js` → Nouveau serveur (livraison directe) ✅ Corrigé&#10;- `server-complete-fixed.js` → Ancien serveur (tout en BDD) ✅ Fonctionnel&#10;- `migration_add_delivered.sql` → Migration pour nouveau système&#10;- `DirectMessagingViewModel.kt` → Nouveau ViewModel (pas encore utilisé)&#10;- `MessagingViewModel.kt` → Ancien ViewModel (utilisé actuellement)&#10;&#10;##  Vérification&#10;&#10;Pour vérifier quel serveur tourne actuellement :&#10;```bash&#10;# Voir les processus node&#10;ps aux | grep node&#10;&#10;# Vérifier les logs du serveur&#10;# Le nouveau serveur affiche : &quot; Socket.IO ready for DIRECT message delivery&quot;&#10;# L'ancien serveur affiche : &quot;Server listening on port 3000&quot;&#10;```&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server-friendship-fix.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server-friendship-fix.js" />
              <option name="updatedContent" value="// MODIFICATIONS À APPORTER À VOTRE SERVER.JS&#10;// &#10;// 1. Ajouter un Map pour suivre les utilisateurs connectés par userId (pas seulement socketId)&#10;// Remplacer la ligne : const connectedUsers = new Map();&#10;// Par :&#10;&#10;const connectedUsers = new Map(); // { socketId: userId }&#10;const userSockets = new Map();    // { userId: Set&lt;socketId&gt; } - pour envoyer des notifs à un user spécifique&#10;&#10;// 2. Modifier l'événement 'authenticate' pour enregistrer dans userSockets&#10;// Dans io.on('connection', ...) &gt; socket.on('authenticate', ...), AJOUTER après `socket.userId = userId;` :&#10;&#10;      // Enregistrer le socket pour cet utilisateur&#10;      if (!userSockets.has(userId)) {&#10;        userSockets.set(userId, new Set());&#10;      }&#10;      userSockets.get(userId).add(socket.id);&#10;&#10;// 3. Modifier l'événement 'disconnect' pour nettoyer userSockets&#10;// Remplacer le code existant dans socket.on('disconnect', ...) par :&#10;&#10;   socket.on('disconnect', () =&gt; {&#10;     const userId = connectedUsers.get(socket.id);&#10;     if (userId) {&#10;       console.log(`User ${userId} disconnected (socket ${socket.id})`);&#10;       connectedUsers.delete(socket.id);&#10;       &#10;       // Retirer ce socket de userSockets&#10;       const sockets = userSockets.get(userId);&#10;       if (sockets) {&#10;         sockets.delete(socket.id);&#10;         if (sockets.size === 0) {&#10;           userSockets.delete(userId);&#10;         }&#10;       }&#10;     } else {&#10;       console.log('Socket disconnected:', socket.id);&#10;     }&#10;   });&#10;&#10;// 4. MODIFIER L'ENDPOINT DELETE /friends/:id pour notifier l'autre utilisateur&#10;// Remplacer tout le code de app.delete('/friends/:id', ...) par :&#10;&#10;app.delete('/friends/:id', authenticateJWT, async (req, res) =&gt; {&#10;  try {&#10;    const userId = req.user.userId;&#10;    const friendshipId = parseInt(req.params.id);&#10;&#10;    console.log(`[DELETE /friends/:id] User ${userId} supprime friendship ${friendshipId}`);&#10;&#10;    // Find the friend request&#10;    const friendRequest = await FriendRequest.findByPk(friendshipId);&#10;&#10;    if (!friendRequest) {&#10;      return res.status(404).json({&#10;        error: 'not_found',&#10;        message: 'Amitié introuvable'&#10;      });&#10;    }&#10;&#10;    // Check if user is part of this friendship&#10;    if (friendRequest.senderId !== userId &amp;&amp; friendRequest.receiverId !== userId) {&#10;      return res.status(403).json({&#10;        error: 'forbidden',&#10;        message: 'Vous ne pouvez pas supprimer cette amitié'&#10;      });&#10;    }&#10;&#10;    // Déterminer l'ID de l'autre utilisateur (l'ami qui va être supprimé)&#10;    const otherUserId = friendRequest.senderId === userId &#10;      ? friendRequest.receiverId &#10;      : friendRequest.senderId;&#10;&#10;    // Delete the friendship&#10;    await friendRequest.destroy();&#10;&#10;    console.log(`[DELETE /friends/:id] Friendship ${friendshipId} supprimée`);&#10;&#10;    // NOUVEAU : Notifier l'autre utilisateur via Socket.IO&#10;    const otherUserSocketIds = userSockets.get(otherUserId);&#10;    if (otherUserSocketIds &amp;&amp; otherUserSocketIds.size &gt; 0) {&#10;      console.log(`[DELETE /friends/:id] Notification envoyée à l'utilisateur ${otherUserId} (${otherUserSocketIds.size} sockets)`);&#10;      otherUserSocketIds.forEach(socketId =&gt; {&#10;        io.to(socketId).emit('friendship_deleted', {&#10;          friendshipId,&#10;          deletedBy: userId,&#10;          message: 'Un ami vous a supprimé de sa liste'&#10;        });&#10;      });&#10;    } else {&#10;      console.log(`[DELETE /friends/:id] Utilisateur ${otherUserId} non connecté`);&#10;    }&#10;&#10;    res.json({ message: 'Ami supprimé avec succès' });&#10;  } catch (err) {&#10;    console.error('DELETE /friends/:id failed:', err);&#10;    res.status(500).json({ error: 'internal_error' });&#10;  }&#10;});&#10;&#10;// 5. PAREIL pour l'acceptation/refus de demande d'ami - modifier PUT /friends/request/:id&#10;// Ajouter une notification après la mise à jour du statut :&#10;&#10;app.put('/friends/request/:id', authenticateJWT, async (req, res) =&gt; {&#10;  try {&#10;    const userId = req.user.userId;&#10;    const requestId = parseInt(req.params.id);&#10;    const { action } = req.body || {}; // 'accept' or 'decline'&#10;&#10;    console.log(`[/friends/request/:id] User ${userId} - action: ${action} sur demande ${requestId}`);&#10;&#10;    // Validation&#10;    if (!action || !['accept', 'decline'].includes(action)) {&#10;      return res.status(400).json({&#10;        error: 'bad_request',&#10;        message: 'action doit être &quot;accept&quot; ou &quot;decline&quot;'&#10;      });&#10;    }&#10;&#10;    // Find the friend request&#10;    const friendRequest = await FriendRequest.findByPk(requestId);&#10;&#10;    if (!friendRequest) {&#10;      return res.status(404).json({&#10;        error: 'not_found',&#10;        message: 'Demande introuvable'&#10;      });&#10;    }&#10;&#10;    // Check if current user is the receiver&#10;    if (friendRequest.receiverId !== userId) {&#10;      return res.status(403).json({&#10;        error: 'forbidden',&#10;        message: 'Vous ne pouvez pas modifier cette demande'&#10;      });&#10;    }&#10;&#10;    // Check if already processed&#10;    if (friendRequest.status !== 'pending') {&#10;      return res.status(400).json({&#10;        error: 'bad_request',&#10;        message: 'Cette demande a déjà été traitée'&#10;      });&#10;    }&#10;&#10;    // Update status&#10;    const newStatus = action === 'accept' ? 'accepted' : 'declined';&#10;    await friendRequest.update({&#10;      status: newStatus,&#10;      updatedAt: new Date()&#10;    });&#10;&#10;    console.log(`[/friends/request/:id] Statut mis à jour: ${newStatus}`);&#10;&#10;    // NOUVEAU : Notifier le sender via Socket.IO&#10;    const senderSocketIds = userSockets.get(friendRequest.senderId);&#10;    if (senderSocketIds &amp;&amp; senderSocketIds.size &gt; 0) {&#10;      console.log(`[/friends/request/:id] Notification envoyée au sender ${friendRequest.senderId}`);&#10;      senderSocketIds.forEach(socketId =&gt; {&#10;        io.to(socketId).emit('friend_request_updated', {&#10;          requestId: friendRequest.id,&#10;          status: newStatus,&#10;          message: action === 'accept' &#10;            ? 'Votre demande d\'ami a été acceptée' &#10;            : 'Votre demande d\'ami a été refusée'&#10;        });&#10;      });&#10;    }&#10;&#10;    res.json({&#10;      message: action === 'accept' ? 'Demande acceptée' : 'Demande refusée',&#10;      id: friendRequest.id,&#10;      status: newStatus&#10;    });&#10;  } catch (err) {&#10;    console.error('PUT /friends/request/:id failed:', err);&#10;    res.status(500).json({ error: 'internal_error' });&#10;  }&#10;});&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>